--- edit/edit-widget.h
+++ edit/edit-widget.h
@@ -25,6 +25,11 @@
     unsigned char border;
 };
 
+struct action {
+    wchar_t ch;
+    long flags;
+};
+
 struct WEdit {
     Widget widget;
 
@@ -38,8 +43,12 @@
     /* dynamic buffers and cursor position for editor: */
     long curs1;			/* position of the cursor from the beginning of the file. */
     long curs2;			/* position from the end of the file */
-    unsigned char *buffers1[MAXBUFF + 1];	/* all data up to curs1 */
-    unsigned char *buffers2[MAXBUFF + 1];	/* all data from end of file down to curs2 */
+    wchar_t *buffers1[MAXBUFF + 1];	/* all data up to curs1 */
+    wchar_t *buffers2[MAXBUFF + 1];	/* all data from end of file down to curs2 */
+
+    unsigned char charbuf[MB_LEN_MAX];
+    int charpoint;
+
 
     /* search variables */
     long search_start;		/* First character to start searching from */
@@ -84,7 +93,7 @@
 
     /* undo stack and pointers */
     unsigned long stack_pointer;
-    long *undo_stack;
+    struct action *undo_stack;
     unsigned long stack_size;
     unsigned long stack_size_mask;
     unsigned long stack_bottom;
--- edit/edit.c
+++ edit/edit.c
@@ -97,7 +97,7 @@
 
 #ifndef NO_INLINE_GETBYTE
 
-int edit_get_byte (WEdit * edit, long byte_index)
+wchar_t edit_get_byte (WEdit * edit, long byte_index)
 {
     unsigned long p;
     if (byte_index >= (edit->curs1 + edit->curs2) || byte_index < 0)
@@ -129,7 +129,7 @@
 
     edit->curs1 = 0;
     edit->curs2 = 0;
-    edit->buffers2[0] = g_malloc (EDIT_BUF_SIZE);
+    edit->buffers2[0] = g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 }
 
 /*
@@ -156,7 +156,7 @@
     }
 
     if (!edit->buffers2[buf2])
-	edit->buffers2[buf2] = g_malloc (EDIT_BUF_SIZE);
+	edit->buffers2[buf2] = g_malloc (EDIT_BUF_SIZE  * sizeof(wchar_t));
 
     mc_read (file,
 	     (char *) edit->buffers2[buf2] + EDIT_BUF_SIZE -
@@ -166,7 +166,7 @@
     for (buf = buf2 - 1; buf >= 0; buf--) {
 	/* edit->buffers2[0] is already allocated */
 	if (!edit->buffers2[buf])
-	    edit->buffers2[buf] = g_malloc (EDIT_BUF_SIZE);
+	    edit->buffers2[buf] = g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 	mc_read (file, (char *) edit->buffers2[buf], EDIT_BUF_SIZE);
     }
 
@@ -245,11 +245,41 @@
 static long
 edit_insert_stream (WEdit * edit, FILE * f)
 {
-    int c;
+    wchar_t c;
     long i = 0;
-    while ((c = fgetc (f)) >= 0) {
-	edit_insert (edit, c);
-	i++;
+    unsigned char buf[MB_LEN_MAX];
+    int charpos = 0;
+    mbstate_t mbs;
+	
+    
+    while ((c = fgetc (f)) != WEOF) {
+	wchar_t wc;
+	int size;
+	int j;
+	
+	buf[charpos++] = c;
+	
+        memset (&mbs, 0, sizeof (mbs));
+	size = mbrtowc(&wc, buf, charpos, &mbs);
+	
+	if (size == -2) 
+	    continue; /* incomplete */
+	
+	else if (size >= 0) {
+	    edit_insert (edit, wc);
+	    i++;
+	    charpos = 0;
+	    continue;
+	}
+	else {
+	
+		/* invalid  */
+#ifdef __STDC_ISO_10646__
+		for (j=0; j<charpos; j++)
+		    edit_insert (edit, BINARY_CHAR_OFFSET + (wchar_t)buf[j]);
+#endif
+		charpos = 0;
+	}
     }
     return i;
 }
@@ -257,9 +287,26 @@
 long edit_write_stream (WEdit * edit, FILE * f)
 {
     long i;
-    for (i = 0; i < edit->last_byte; i++)
-	if (fputc (edit_get_byte (edit, i), f) < 0)
-	    break;
+    for (i = 0; i < edit->last_byte; i++) {
+	wchar_t wc = edit_get_byte (edit, i);
+	int res;
+	char tmpbuf[MB_LEN_MAX];
+        mbstate_t mbs;
+
+        memset (&mbs, 0, sizeof (mbs));
+	
+#ifdef __STDC_ISO_10646__ 
+	if (wc >= BINARY_CHAR_OFFSET && wc < (BINARY_CHAR_OFFSET + 256)) {
+	    res = 1;
+	    tmpbuf[0] = (char) (wc - BINARY_CHAR_OFFSET);
+	} else
+#endif
+	res = wcrtomb(tmpbuf, wc, &mbs);
+	if (res > 0) {
+	    if (fwrite(tmpbuf, res, 1, f) != 1)
+		break;
+	}
+    }
     return i;
 }
 
@@ -299,12 +346,38 @@
 	int i, file, blocklen;
 	long current = edit->curs1;
 	unsigned char *buf;
+	mbstate_t mbs;
+	int bufstart = 0;
+	
+	memset (&mbs, 0, sizeof (mbs));
 	if ((file = mc_open (filename, O_RDONLY | O_BINARY)) == -1)
 	    return 0;
 	buf = g_malloc (TEMP_BUF_LEN);
-	while ((blocklen = mc_read (file, (char *) buf, TEMP_BUF_LEN)) > 0) {
-	    for (i = 0; i < blocklen; i++)
-		edit_insert (edit, buf[i]);
+	while ((blocklen = mc_read (file, (char *) buf + bufstart, TEMP_BUF_LEN - bufstart)) > 0) {
+	    blocklen += bufstart;
+	    bufstart = 0;
+	    for (i = 0; i < blocklen; ) {
+		wchar_t wc;
+		int j;
+	        int size = mbrtowc(&wc, buf + i, blocklen - i, &mbs);
+		if (size == -2) { /*incomplete char*/
+		    bufstart = blocklen - i;
+		    memcpy(buf, buf+i, bufstart);
+		    i = blocklen;
+		    memset (&mbs, 0, sizeof (mbs));
+		}
+		else if (size <= 0) {
+#ifdef __STDC_ISO_10646__
+		    edit_insert (edit, BINARY_CHAR_OFFSET + (wchar_t)buf[i]);
+#endif
+		    memset (&mbs, 0, sizeof (mbs));
+		    i++; /* skip broken char */
+		}
+		else {
+		    edit_insert (edit, wc);
+		    i+=size;
+		}
+	    }
 	}
 	edit_cursor_move (edit, current - edit->curs1);
 	g_free (buf);
@@ -398,7 +471,7 @@
 static int
 edit_load_file (WEdit *edit)
 {
-    int fast_load = 1;
+    int fast_load = 0; /* can't be used with multibyte caracters */
 
     /* Cannot do fast load if a filter is used */
     if (edit_find_filter (edit->filename) >= 0)
@@ -546,7 +619,7 @@
     edit_set_filename (edit, filename);
     edit->stack_size = START_STACK_SIZE;
     edit->stack_size_mask = START_STACK_SIZE - 1;
-    edit->undo_stack = g_malloc ((edit->stack_size + 10) * sizeof (long));
+    edit->undo_stack = g_malloc ((edit->stack_size + 10) * sizeof (struct action));
     if (edit_load_file (edit)) {
 	/* edit_load_file already gives an error message */
 	if (to_free)
@@ -569,7 +642,7 @@
 	edit_move_display (edit, line - 1);
 	edit_move_to_line (edit, line - 1);
     }
-
+    edit->charpoint = 0;
     return edit;
 }
 
@@ -690,13 +763,23 @@
 {
     unsigned long sp = edit->stack_pointer;
     unsigned long spm1;
-    long *t;
+    struct action *t;
+    wchar_t ch = 0;
+    
+    if (c == CHAR_INSERT || c == CHAR_INSERT_AHEAD) {
+	va_list ap;
+	va_start (ap, c);
+	ch = va_arg (ap, wchar_t);
+	va_end (ap);
+    }
+
+
 /* first enlarge the stack if necessary */
     if (sp > edit->stack_size - 10) {	/* say */
 	if (option_max_undo < 256)
 	    option_max_undo = 256;
 	if (edit->stack_size < option_max_undo) {
-	    t = g_realloc (edit->undo_stack, (edit->stack_size * 2 + 10) * sizeof (long));
+	    t = g_realloc (edit->undo_stack, (edit->stack_size * 2 + 10) * sizeof (struct action));
 	    if (t) {
 		edit->undo_stack = t;
 		edit->stack_size <<= 1;
@@ -711,7 +794,7 @@
 #ifdef FAST_MOVE_CURSOR
     if (c == CURS_LEFT_LOTS || c == CURS_RIGHT_LOTS) {
 	va_list ap;
-	edit->undo_stack[sp] = c == CURS_LEFT_LOTS ? CURS_LEFT : CURS_RIGHT;
+	edit->undo_stack[sp].flags = c == CURS_LEFT_LOTS ? CURS_LEFT : CURS_RIGHT;
 	edit->stack_pointer = (edit->stack_pointer + 1) & edit->stack_size_mask;
 	va_start (ap, c);
 	c = -(va_arg (ap, int));
@@ -722,12 +805,14 @@
 	&& spm1 != edit->stack_bottom
 	&& ((sp - 2) & edit->stack_size_mask) != edit->stack_bottom) {
 	int d;
-	if (edit->undo_stack[spm1] < 0) {
-	    d = edit->undo_stack[(sp - 2) & edit->stack_size_mask];
-	    if (d == c) {
-		if (edit->undo_stack[spm1] > -1000000000) {
+	wchar_t d_ch;
+	if (edit->undo_stack[spm1].flags < 0) {
+	    d    = edit->undo_stack[(sp - 2) & edit->stack_size_mask].flags;
+	    d_ch = edit->undo_stack[(sp - 2) & edit->stack_size_mask].ch;
+	    if (d == c && d_ch == ch) {
+		if (edit->undo_stack[spm1].flags > -1000000000) {
 		    if (c < KEY_PRESS)	/* --> no need to push multiple do-nothings */
-			edit->undo_stack[spm1]--;
+			edit->undo_stack[spm1].flags--;
 		    return;
 		}
 	    }
@@ -735,19 +820,20 @@
 #ifndef NO_STACK_CURSMOVE_ANIHILATION
 	    else if ((c == CURS_LEFT && d == CURS_RIGHT)
 		     || (c == CURS_RIGHT && d == CURS_LEFT)) {	/* a left then a right anihilate each other */
-		if (edit->undo_stack[spm1] == -2)
+		if (edit->undo_stack[spm1].flags == -2)
 		    edit->stack_pointer = spm1;
 		else
-		    edit->undo_stack[spm1]++;
+		    edit->undo_stack[spm1].flags++;
 		return;
 	    }
 #endif
 	} else {
-	    d = edit->undo_stack[spm1];
-	    if (d == c) {
+	    d    = edit->undo_stack[spm1].flags;
+	    d_ch = edit->undo_stack[spm1].ch;
+	    if (d == c && d_ch == ch) {
 		if (c >= KEY_PRESS)
 		    return;	/* --> no need to push multiple do-nothings */
-		edit->undo_stack[sp] = -2;
+		edit->undo_stack[sp].flags = -2;
 		goto check_bottom;
 	    }
 #ifndef NO_STACK_CURSMOVE_ANIHILATION
@@ -759,7 +845,9 @@
 #endif
 	}
     }
-    edit->undo_stack[sp] = c;
+    edit->undo_stack[sp].flags = c;
+    edit->undo_stack[sp].ch = ch;
+
   check_bottom:
 
     edit->stack_pointer = (edit->stack_pointer + 1) & edit->stack_size_mask;
@@ -769,10 +857,10 @@
     if (c == edit->stack_bottom || ((c + 1) & edit->stack_size_mask) == edit->stack_bottom)
 	do {
 	    edit->stack_bottom = (edit->stack_bottom + 1) & edit->stack_size_mask;
-	} while (edit->undo_stack[edit->stack_bottom] < KEY_PRESS && edit->stack_bottom != edit->stack_pointer);
+	} while (edit->undo_stack[edit->stack_bottom].flags < KEY_PRESS && edit->stack_bottom != edit->stack_pointer);
 
 /*If a single key produced enough pushes to wrap all the way round then we would notice that the [stack_bottom] does not contain KEY_PRESS. The stack is then initialised: */
-    if (edit->stack_pointer != edit->stack_bottom && edit->undo_stack[edit->stack_bottom] < KEY_PRESS)
+    if (edit->stack_pointer != edit->stack_bottom && edit->undo_stack[edit->stack_bottom].flags < KEY_PRESS)
 	edit->stack_bottom = edit->stack_pointer = 0;
 }
 
@@ -781,30 +869,33 @@
    then the file should be as it was when he loaded up. Then set edit->modified to 0.
  */
 static long
-pop_action (WEdit * edit)
+pop_action (WEdit * edit, struct action *c)
 {
-    long c;
     unsigned long sp = edit->stack_pointer;
     if (sp == edit->stack_bottom) {
-	return STACK_BOTTOM;
+	c->flags = STACK_BOTTOM;
+	return c->flags;
     }
     sp = (sp - 1) & edit->stack_size_mask;
-    if ((c = edit->undo_stack[sp]) >= 0) {
+
+    *c = edit->undo_stack[sp];
+    if (edit->undo_stack[sp].flags >= 0) {
 /*	edit->undo_stack[sp] = '@'; */
 	edit->stack_pointer = (edit->stack_pointer - 1) & edit->stack_size_mask;
-	return c;
+	return c->flags;
     }
     if (sp == edit->stack_bottom) {
 	return STACK_BOTTOM;
     }
-    c = edit->undo_stack[(sp - 1) & edit->stack_size_mask];
-    if (edit->undo_stack[sp] == -2) {
+    *c = edit->undo_stack[(sp - 1) & edit->stack_size_mask];
+    
+    if (edit->undo_stack[sp].flags == -2) {
 /*      edit->undo_stack[sp] = '@'; */
 	edit->stack_pointer = sp;
     } else
-	edit->undo_stack[sp]++;
+	edit->undo_stack[sp].flags++;
 
-    return c;
+    return c->flags;
 }
 
 /* is called whenever a modification is made by one of the four routines below */
@@ -821,7 +912,7 @@
  */
 
 void
-edit_insert (WEdit *edit, int c)
+edit_insert (WEdit *edit, wchar_t c)
 {
     /* check if file has grown to large */
     if (edit->last_byte >= SIZE_LIMIT)
@@ -855,12 +946,12 @@
     /* add a new buffer if we've reached the end of the last one */
     if (!(edit->curs1 & M_EDIT_BUF_SIZE))
 	edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] =
-	    g_malloc (EDIT_BUF_SIZE);
+	    g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 
     /* perform the insertion */
     edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE][edit->
 						   curs1 & M_EDIT_BUF_SIZE]
-	= (unsigned char) c;
+	= c;
 
     /* update file length */
     edit->last_byte++;
@@ -871,7 +962,7 @@
 
 
 /* same as edit_insert and move left */
-void edit_insert_ahead (WEdit * edit, int c)
+void edit_insert_ahead (WEdit * edit, wchar_t c)
 {
     if (edit->last_byte >= SIZE_LIMIT)
 	return;
@@ -894,7 +985,7 @@
     edit->last_get_rule += (edit->last_get_rule >= edit->curs1);
 
     if (!((edit->curs2 + 1) & M_EDIT_BUF_SIZE))
-	edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE);
+	edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
     edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE - (edit->curs2 & M_EDIT_BUF_SIZE) - 1] = c;
 
     edit->last_byte++;
@@ -904,7 +995,7 @@
 
 int edit_delete (WEdit * edit)
 {
-    int p;
+    wchar_t p;
     if (!edit->curs2)
 	return 0;
 
@@ -927,7 +1018,7 @@
 	edit->total_lines--;
 	edit->force |= REDRAW_AFTER_CURSOR;
     }
-    edit_push_action (edit, p + 256);
+    edit_push_action (edit, CHAR_INSERT_AHEAD, p);
     if (edit->curs1 < edit->start_display) {
 	edit->start_display--;
 	if (p == '\n')
@@ -942,7 +1033,7 @@
 static int
 edit_backspace (WEdit * edit)
 {
-    int p;
+    wchar_t p;
     if (!edit->curs1)
 	return 0;
 
@@ -965,7 +1056,7 @@
 	edit->total_lines--;
 	edit->force |= REDRAW_AFTER_CURSOR;
     }
-    edit_push_action (edit, p);
+    edit_push_action (edit, CHAR_INSERT, p);
 
     if (edit->curs1 < edit->start_display) {
 	edit->start_display--;
@@ -979,10 +1070,14 @@
 
 #ifdef FAST_MOVE_CURSOR
 
-static void memqcpy (WEdit * edit, unsigned char *dest, unsigned char *src, int n)
+static void memqcpy (WEdit * edit, wchar_t *dest, wchar_t *src, int n)
 {
     unsigned long next;
-    while ((next = (unsigned long) memccpy (dest, src, '\n', n))) {
+    while (n) {
+	next = 0;
+	while (next < n && src[next]!='\n') next++;
+	if (next < n) next++;
+        wmemcpy (dest, src, next)
 	edit->curs_line--;
 	next -= (unsigned long) dest;
 	n -= next;
@@ -995,7 +1090,7 @@
 edit_move_backward_lots (WEdit *edit, long increment)
 {
     int r, s, t;
-    unsigned char *p;
+    wchar_t *p;
 
     if (increment > edit->curs1)
 	increment = edit->curs1;
@@ -1035,7 +1130,7 @@
 	    edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = p;
 	else
 	    edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] =
-		g_malloc (EDIT_BUF_SIZE);
+		g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
     } else {
 	if (p)
 	    g_free (p);
@@ -1074,7 +1169,7 @@
 		edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] = p;
 	    else
 		edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE] =
-		    g_malloc (EDIT_BUF_SIZE);
+		    g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 	} else {
 	    g_free (p);
 	}
@@ -1106,7 +1201,7 @@
 
 	    c = edit_get_byte (edit, edit->curs1 - 1);
 	    if (!((edit->curs2 + 1) & M_EDIT_BUF_SIZE))
-		edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE);
+		edit->buffers2[(edit->curs2 + 1) >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 	    edit->buffers2[edit->curs2 >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE - (edit->curs2 & M_EDIT_BUF_SIZE) - 1] = c;
 	    edit->curs2++;
 	    c = edit->buffers1[(edit->curs1 - 1) >> S_EDIT_BUF_SIZE][(edit->curs1 - 1) & M_EDIT_BUF_SIZE];
@@ -1131,7 +1226,7 @@
 
 	    c = edit_get_byte (edit, edit->curs1);
 	    if (!(edit->curs1 & M_EDIT_BUF_SIZE))
-		edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE);
+		edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE] = g_malloc (EDIT_BUF_SIZE * sizeof(wchar_t));
 	    edit->buffers1[edit->curs1 >> S_EDIT_BUF_SIZE][edit->curs1 & M_EDIT_BUF_SIZE] = c;
 	    edit->curs1++;
 	    c = edit->buffers2[(edit->curs2 - 1) >> S_EDIT_BUF_SIZE][EDIT_BUF_SIZE - ((edit->curs2 - 1) & M_EDIT_BUF_SIZE) - 1];
@@ -1389,7 +1484,7 @@
 is_blank (WEdit *edit, long offset)
 {
     long s, f;
-    int c;
+    wchar_t c;
     s = edit_bol (edit, offset);
     f = edit_eol (edit, offset) - 1;
     while (s <= f) {
@@ -1624,11 +1719,11 @@
     selection_history[current_selection].text =
 	g_malloc (selection_history[current_selection].len + 1);
     if (!selection_history[current_selection].text) {
-	selection_history[current_selection].text = g_malloc (1);
+	selection_history[current_selection].text = g_malloc (sizeof(wchar_t));
 	*selection_history[current_selection].text = 0;
 	selection_history[current_selection].len = 0;
     } else {
-	unsigned char *p = selection_history[current_selection].text;
+	wchar_t *p = selection_history[current_selection].text;
 	for (; start_mark < end_mark; start_mark++)
 	    *p++ = edit_get_byte (edit, start_mark);
 	*p = 0;
@@ -1787,13 +1882,13 @@
 static void
 edit_do_undo (WEdit * edit)
 {
-    long ac;
+    struct action ac;
     long count = 0;
 
     edit->stack_disable = 1;	/* don't record undo's onto undo stack! */
 
-    while ((ac = pop_action (edit)) < KEY_PRESS) {
-	switch ((int) ac) {
+    while (pop_action (edit, &ac) < KEY_PRESS) {
+	switch ((int) ac.flags) {
 	case STACK_BOTTOM:
 	    goto done_undo;
 	case CURS_RIGHT:
@@ -1814,31 +1909,33 @@
 	case COLUMN_OFF:
 	    column_highlighting = 0;
 	    break;
+	case CHAR_INSERT:
+	    edit_insert (edit, ac.ch);
+	    break;
+	case CHAR_INSERT_AHEAD:
+	    edit_insert_ahead (edit, ac.ch);
+	    break;
 	}
-	if (ac >= 256 && ac < 512)
-	    edit_insert_ahead (edit, ac - 256);
-	if (ac >= 0 && ac < 256)
-	    edit_insert (edit, ac);
 
-	if (ac >= MARK_1 - 2 && ac < MARK_2 - 2) {
-	    edit->mark1 = ac - MARK_1;
+	if (ac.flags >= MARK_1 - 2 && ac.flags < MARK_2 - 2) {
+	    edit->mark1 = ac.flags - MARK_1;
 	    edit->column1 = edit_move_forward3 (edit, edit_bol (edit, edit->mark1), 0, edit->mark1);
-	} else if (ac >= MARK_2 - 2 && ac < KEY_PRESS) {
-	    edit->mark2 = ac - MARK_2;
+	} else if (ac.flags >= MARK_2 - 2 && ac.flags < KEY_PRESS) {
+	    edit->mark2 = ac.flags - MARK_2;
 	    edit->column2 = edit_move_forward3 (edit, edit_bol (edit, edit->mark2), 0, edit->mark2);
 	}
 	if (count++)
 	    edit->force |= REDRAW_PAGE;		/* more than one pop usually means something big */
     }
 
-    if (edit->start_display > ac - KEY_PRESS) {
-	edit->start_line -= edit_count_lines (edit, ac - KEY_PRESS, edit->start_display);
+    if (edit->start_display > ac.flags - KEY_PRESS) {
+	edit->start_line -= edit_count_lines (edit, ac.flags - KEY_PRESS, edit->start_display);
 	edit->force |= REDRAW_PAGE;
-    } else if (edit->start_display < ac - KEY_PRESS) {
-	edit->start_line += edit_count_lines (edit, edit->start_display, ac - KEY_PRESS);
+    } else if (edit->start_display < ac.flags - KEY_PRESS) {
+	edit->start_line += edit_count_lines (edit, edit->start_display, ac.flags - KEY_PRESS);
 	edit->force |= REDRAW_PAGE;
     }
-    edit->start_display = ac - KEY_PRESS;	/* see push and pop above */
+    edit->start_display = ac.flags - KEY_PRESS;	/* see push and pop above */
     edit_update_curs_row (edit);
 
   done_undo:;
@@ -2114,7 +2211,7 @@
 /* one of command or char_for_insertion must be passed as -1 */
 /* commands are executed, and char_for_insertion is inserted at the cursor */
 /* returns 0 if the command is a macro that was not found, 1 otherwise */
-int edit_execute_key_command (WEdit * edit, int command, int char_for_insertion)
+int edit_execute_key_command (WEdit * edit, int command, wchar_t char_for_insertion)
 {
     int r;
     if (command == CK_Begin_Record_Macro) {
@@ -2153,7 +2250,7 @@
    Returns 0 if the command is a macro that was not found, 1
    otherwise.
  */
-int edit_execute_cmd (WEdit * edit, int command, int char_for_insertion)
+int edit_execute_cmd (WEdit * edit, int command, wchar_t char_for_insertion)
 {
     int result = 1;
     edit->force |= REDRAW_LINE;
@@ -2669,7 +2766,7 @@
 
 /* either command or char_for_insertion must be passed as -1 */
 /* returns 0 if command is a macro that was not found, 1 otherwise */
-int edit_execute_command (WEdit * edit, int command, int char_for_insertion)
+int edit_execute_command (WEdit * edit, int command, wchar_t char_for_insertion)
 {
     int r;
     r = edit_execute_cmd (edit, command, char_for_insertion);
--- edit/edit.h
+++ edit/edit.h
@@ -22,6 +22,7 @@
 
 #ifndef __EDIT_H
 #define __EDIT_H
+#define _ISOC99_SOURCE 
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -37,8 +38,14 @@
 
 #include <stdlib.h>
 
+#include <wchar.h>
+#include <wctype.h>
+
 #include "src/global.h"
 
+/* unicode private use area */
+#define BINARY_CHAR_OFFSET 0xFFE00
+
 #    define WIDGET_COMMAND (WIDGET_USER + 10)
 #    define N_menus 5
 
@@ -89,6 +96,8 @@
 
 
 /*some codes that may be pushed onto or returned from the undo stack: */
+#define CHAR_INSERT 65
+#define CHAR_INSERT_AHEAD 66
 #define CURS_LEFT 601
 #define CURS_RIGHT 602
 #define DELCHAR 603
@@ -108,11 +117,11 @@
 
 struct macro {
     short command;
-    short ch;
+    wchar_t ch;
 };
 
 struct selection {
-   unsigned char * text;
+   wchar_t * text;
    int len;
 };
 
@@ -128,12 +137,13 @@
 int edit_raw_key_query (char *heading, char *query, int cancel);
 char *strcasechr (const unsigned char *s, int c);
 int edit (const char *_file, int line);
-int edit_translate_key (WEdit *edit, long x_key, int *cmd, int *ch);
+int edit_translate_key (WEdit *edit, long x_key, int *cmd, wchar_t *ch);
 
-#ifndef NO_INLINE_GETBYTE
-int edit_get_byte (WEdit * edit, long byte_index);
+//ifndef NO_INLINE_GETBYTE
+#if 1
+wchar_t edit_get_byte (WEdit * edit, long byte_index);
 #else
-static inline int edit_get_byte (WEdit * edit, long byte_index)
+static inline wchar_t edit_get_byte (WEdit * edit, long byte_index)
 {
     unsigned long p;
     if (byte_index >= (edit->curs1 + edit->curs2) || byte_index < 0)
@@ -173,11 +183,11 @@
 void edit_delete_line (WEdit * edit);
 
 int edit_delete (WEdit * edit);
-void edit_insert (WEdit * edit, int c);
+void edit_insert (WEdit * edit, wchar_t c);
 int edit_cursor_move (WEdit * edit, long increment);
 void edit_push_action (WEdit * edit, long c, ...);
 void edit_push_key_press (WEdit * edit);
-void edit_insert_ahead (WEdit * edit, int c);
+void edit_insert_ahead (WEdit * edit, wchar_t c);
 int edit_save_file (WEdit * edit, const char *filename);
 long edit_write_stream (WEdit * edit, FILE * f);
 char *edit_get_write_filter (const char *writename, const char *filename);
@@ -210,16 +220,17 @@
 void edit_goto_cmd (WEdit * edit);
 int eval_marks (WEdit * edit, long *start_mark, long *end_mark);
 void edit_status (WEdit * edit);
-int edit_execute_command (WEdit * edit, int command, int char_for_insertion);
-int edit_execute_key_command (WEdit * edit, int command, int char_for_insertion);
+int edit_execute_command (WEdit * edit, int command, wchar_t char_for_insertion);
+int edit_execute_key_command (WEdit * edit, int command, wchar_t char_for_insertion);
 void edit_update_screen (WEdit * edit);
 int edit_printf (WEdit * e, const char *fmt, ...)
     __attribute__ ((format (printf, 2, 3)));
 int edit_print_string (WEdit * e, const char *s);
+int edit_print_wstring (WEdit * e, wchar_t *s);
 void edit_move_to_line (WEdit * e, long line);
 void edit_move_display (WEdit * e, long line);
 void edit_word_wrap (WEdit * edit);
-unsigned char *edit_get_block (WEdit * edit, long start, long finish, int *l);
+wchar_t *edit_get_block (WEdit * edit, long start, long finish, int *l);
 int edit_sort_cmd (WEdit * edit);
 void edit_help_cmd (WEdit * edit);
 void edit_left_word_move (WEdit * edit, int s);
@@ -261,7 +272,7 @@
 void format_paragraph (WEdit *edit, int force);
 
 /* either command or char_for_insertion must be passed as -1 */
-int edit_execute_cmd (WEdit * edit, int command, int char_for_insertion);
+int edit_execute_cmd (WEdit * edit, int command, wchar_t char_for_insertion);
 
 #define get_sys_error(s) (s)
 
--- edit/editcmd.c
+++ edit/editcmd.c
@@ -22,7 +22,6 @@
 */
 
 /* #define PIPE_BLOCKS_SO_READ_BYTE_BY_BYTE */
-
 #include <config.h>
 #include <ctype.h>
 
@@ -95,12 +94,13 @@
 }
 #endif /* !HAVE_MEMMOVE */
 
-/* #define itoa MY_itoa  <---- this line is now in edit.h */
-static char *
+/* #define itoa 
+MY_itoa  <---- this line is now in edit.h */
+static wchar_t *
 MY_itoa (int i)
 {
-    static char t[14];
-    char *s = t + 13;
+    static wchar_t t[14];
+    wchar_t *s = t + 13;
     int j = i;
     *s-- = 0;
     do {
@@ -184,6 +184,46 @@
     doupdate();
 }
 
+
+
+static size_t 
+wchar_write(int fd, wchar_t *buf, size_t len)
+{
+    char *tmpbuf = g_malloc(len + MB_LEN_MAX);
+    mbstate_t mbs;
+    size_t i;
+    size_t outlen = 0;
+    size_t res;
+    
+    for (i = 0; i < len; i++) {
+	if (outlen >= len) {
+	    if ((res = mc_write(fd, tmpbuf, outlen)) != outlen) {
+		g_free(tmpbuf);
+		return -1;
+	    }
+	    outlen = 0;
+	}
+	memset (&mbs, 0, sizeof (mbs));
+#ifdef __STDC_ISO_10646__ 
+	if (buf[i] >= BINARY_CHAR_OFFSET && buf[i] < (BINARY_CHAR_OFFSET + 256)) {
+	    res = 1;
+	    tmpbuf[outlen] = (char) (buf[i] - BINARY_CHAR_OFFSET);
+
+	} else
+#endif
+	res = wcrtomb(tmpbuf + outlen, buf[i], &mbs);
+	if (res > 0) {
+	    outlen += res;
+	}
+    }
+    if ((res = mc_write(fd, tmpbuf, outlen)) != outlen) {
+	g_free(tmpbuf);
+	return -1;
+    }
+    g_free(tmpbuf);
+    return len;
+}
+
 /* "Oleg Yu. Repin" <repin@ssd.sscc.ru> added backup filenames
     ...thanks -paul */
 
@@ -286,32 +326,32 @@
 	buf = 0;
 	filelen = edit->last_byte;
 	while (buf <= (edit->curs1 >> S_EDIT_BUF_SIZE) - 1) {
-	    if (mc_write (fd, (char *) edit->buffers1[buf], EDIT_BUF_SIZE)
+	    if (wchar_write (fd, edit->buffers1[buf], EDIT_BUF_SIZE)
 		!= EDIT_BUF_SIZE) {
 		mc_close (fd);
 		goto error_save;
 	    }
 	    buf++;
 	}
-	if (mc_write
-	    (fd, (char *) edit->buffers1[buf],
+	if (wchar_write
+	    (fd, edit->buffers1[buf],
 	     edit->curs1 & M_EDIT_BUF_SIZE) !=
 	    (edit->curs1 & M_EDIT_BUF_SIZE)) {
 	    filelen = -1;
 	} else if (edit->curs2) {
 	    edit->curs2--;
 	    buf = (edit->curs2 >> S_EDIT_BUF_SIZE);
-	    if (mc_write
+	    if (wchar_write
 		(fd,
-		 (char *) edit->buffers2[buf] + EDIT_BUF_SIZE -
+		 edit->buffers2[buf] + EDIT_BUF_SIZE -
 		 (edit->curs2 & M_EDIT_BUF_SIZE) - 1,
 		 1 + (edit->curs2 & M_EDIT_BUF_SIZE)) !=
 		1 + (edit->curs2 & M_EDIT_BUF_SIZE)) {
 		filelen = -1;
 	    } else {
 		while (--buf >= 0) {
-		    if (mc_write
-			(fd, (char *) edit->buffers2[buf],
+		    if (wchar_write
+			(fd, edit->buffers2[buf],
 			 EDIT_BUF_SIZE) != EDIT_BUF_SIZE) {
 			filelen = -1;
 			break;
@@ -597,13 +637,13 @@
 	if (!n || n == EOF)
 	    break;
 	n = 0;
-	while (fscanf (f, "%hd %hd, ", &macro[n].command, &macro[n].ch))
+	while (fscanf (f, "%hd %lu, ", &macro[n].command, &macro[n].ch))
 	    n++;
 	fscanf (f, ";\n");
 	if (s != k) {
 	    fprintf (g, ("key '%d 0': "), s);
 	    for (i = 0; i < n; i++)
-		fprintf (g, "%hd %hd, ", macro[i].command, macro[i].ch);
+		fprintf (g, "%hd %lu, ", macro[i].command, macro[i].ch);
 	    fprintf (g, ";\n");
 	}
     }
@@ -639,7 +679,7 @@
 	if (f) {
 	    fprintf (f, ("key '%d 0': "), s);
 	    for (i = 0; i < n; i++)
-		fprintf (f, "%hd %hd, ", macro[i].command, macro[i].ch);
+		fprintf (f, "%hd %lu, ", macro[i].command, macro[i].ch);
 	    fprintf (f, ";\n");
 	    fclose (f);
 	    if (saved_macros_loaded) {
@@ -688,10 +728,10 @@
 		saved_macro[i++] = s;
 	    if (!found) {
 		*n = 0;
-		while (*n < MAX_MACRO_LENGTH && 2 == fscanf (f, "%hd %hd, ", &macro[*n].command, &macro[*n].ch))
+		while (*n < MAX_MACRO_LENGTH && 2 == fscanf (f, "%hd %lu, ", &macro[*n].command, &macro[*n].ch))
 		    (*n)++;
 	    } else {
-		while (2 == fscanf (f, "%hd %hd, ", &dummy.command, &dummy.ch));
+		while (2 == fscanf (f, "%hd %lu, ", &dummy.command, &dummy.ch));
 	    }
 	    fscanf (f, ";\n");
 	    if (s == k)
@@ -819,7 +859,7 @@
 #define space_width 1
 
 static void
-edit_insert_column_of_text (WEdit * edit, unsigned char *data, int size, int width)
+edit_insert_column_of_text (WEdit * edit, wchar_t *data, int size, int width)
 {
     long cursor;
     int i, col;
@@ -867,7 +907,7 @@
 {
     long start_mark, end_mark, current = edit->curs1;
     int size, x;
-    unsigned char *copy_buf;
+    wchar_t *copy_buf;
 
     edit_update_curs_col (edit);
     x = edit->curs_col;
@@ -912,7 +952,7 @@
 {
     long count;
     long current;
-    unsigned char *copy_buf;
+    wchar_t *copy_buf;
     long start_mark, end_mark;
     int deleted = 0;
     int x = 0;
@@ -973,7 +1013,7 @@
 	edit_push_action (edit, COLUMN_ON);
 	column_highlighting = 0;
     } else {
-	copy_buf = g_malloc (end_mark - start_mark);
+	copy_buf = g_malloc ((end_mark - start_mark) * sizeof(wchar_t));
 	edit_cursor_move (edit, start_mark - edit->curs1);
 	edit_scroll_screen_over_cursor (edit);
 	count = start_mark;
@@ -1303,7 +1343,7 @@
 /* This function is a modification of mc-3.2.10/src/view.c:regexp_view_search() */
 /* returns -3 on error in pattern, -1 on not found, found_len = 0 if either */
 static int
-string_regexp_search (char *pattern, char *string, int len, int match_type,
+string_regexp_search (char *pattern, wchar_t *wstring, int len, int match_type,
 		      int match_bol, int icase, int *found_len, void *d)
 {
     static regex_t r;
@@ -1311,7 +1351,10 @@
     static int old_type, old_icase;
     regmatch_t *pmatch;
     static regmatch_t s[1];
-
+    char *string;
+    int i;
+    
+    
     pmatch = (regmatch_t *) d;
     if (!pmatch)
 	pmatch = s;
@@ -1331,13 +1374,43 @@
 	old_type = match_type;
 	old_icase = icase;
     }
+    
+    string = wchar_to_mbstr(wstring);
+    if (string == NULL)
+	return -1;
+    
     if (regexec
 	(&r, string, d ? NUM_REPL_ARGS : 1, pmatch,
 	 ((match_bol
 	   || match_type != match_normal) ? 0 : REG_NOTBOL)) != 0) {
 	*found_len = 0;
+	g_free(string);
 	return -1;
     }
+    
+    for (i = 0; i < (d ? NUM_REPL_ARGS : 1); i++) {
+	char tmp;
+	int new_o;
+	
+	if (pmatch[i].rm_so < 0)
+	    continue;
+	tmp = string[pmatch[i].rm_so];
+	string[pmatch[i].rm_so] = 0;
+	new_o = mbstrlen(string);
+	string[pmatch[i].rm_so] = tmp;
+	pmatch[i].rm_so = new_o; 
+
+	if (pmatch[i].rm_eo < 0)
+	    continue;
+	tmp = string[pmatch[i].rm_eo];
+	string[pmatch[i].rm_eo] = 0;
+	new_o = mbstrlen(string);
+	string[pmatch[i].rm_eo] = tmp;
+	pmatch[i].rm_eo = new_o; 
+    }
+    
+    g_free(string);
+    
     *found_len = pmatch[0].rm_eo - pmatch[0].rm_so;
     return (pmatch[0].rm_so);
 }
@@ -1346,11 +1419,14 @@
    (and the above) routines to work properly - paul */
 
 static long
-edit_find_string (long start, unsigned char *exp, int *len, long last_byte, int (*get_byte) (void *, long), void *data, int once_only, void *d)
+edit_find_string (long start, unsigned char *exp_mb, int *len, long last_byte, int (*get_byte) (void *, long), void *data, int once_only, void *d)
 {
     long p, q = 0;
-    long l = strlen ((char *) exp), f = 0;
+    long f = 0;
     int n = 0;
+    wchar_t *exp = mbstr_to_wchar(exp_mb);
+    wchar_t *exp_backup = exp;
+    long l = wcslen(exp);
 
     for (p = 0; p < l; p++)	/* count conversions... */
 	if (exp[p] == '%')
@@ -1358,18 +1434,20 @@
 		n++;
 
     if (replace_scanf || replace_regexp) {
-	int c;
-	unsigned char *buf;
-	unsigned char mbuf[MAX_REPL_LEN * 2 + 3];
+	wchar_t c;
+	wchar_t *buf;
+	wchar_t mbuf[MAX_REPL_LEN * 2 + 3];
 
 	replace_scanf = (!replace_regexp);	/* can't have both */
 
 	buf = mbuf;
 
 	if (replace_scanf) {
-	    unsigned char e[MAX_REPL_LEN];
-	    if (n >= NUM_REPL_ARGS)
+	    wchar_t e[MAX_REPL_LEN];
+	    if (n >= NUM_REPL_ARGS) {
+		g_free(exp_backup);
 		return -3;
+	    }
 
 	    if (replace_case) {
 		for (p = start; p < last_byte && p < start + MAX_REPL_LEN; p++)
@@ -1384,20 +1462,23 @@
 	    }
 
 	    buf[(q = p - start)] = 0;
-	    strcpy ((char *) e, (char *) exp);
-	    strcat ((char *) e, "%n");
+	    wcscpy (e, exp);
+	    wcscat (e, L"%n");
 	    exp = e;
 
 	    while (q) {
 		*((int *) sargs[n]) = 0;	/* --> here was the problem - now fixed: good */
-		if (n == sscanf ((char *) buf, (char *) exp, SCANF_ARGS)) {
+		if (n == swscanf (buf, exp, SCANF_ARGS)) {
 		    if (*((int *) sargs[n])) {
 			*len = *((int *) sargs[n]);
+			g_free(exp_backup);
 			return start;
 		    }
 		}
-		if (once_only)
+		if (once_only) {
 		    return -2;
+		    g_free(exp_backup);
+		}
 		if (q + start < last_byte) {
 		    if (replace_case) {
 			buf[q] = (*get_byte) (data, q + start);
@@ -1411,7 +1492,7 @@
 		start++;
 		buf++;		/* move the window along */
 		if (buf == mbuf + MAX_REPL_LEN) {	/* the window is about to go past the end of array, so... */
-		    memmove (mbuf, buf, strlen ((char *) buf) + 1);	/* reset it */
+		    wmemmove (mbuf, buf, (wcslen (buf) + 1));	/* reset it */
 		    buf = mbuf;
 		}
 		q--;
@@ -1437,10 +1518,11 @@
 
 		buf = mbuf;
 		while (q) {
-		    found_start = string_regexp_search ((char *) exp, (char *) buf, q, match_normal, match_bol, !replace_case, len, d);
+		    found_start = string_regexp_search ((char *) exp_mb, buf, q, match_normal, match_bol, !replace_case, len, d);
 
 		    if (found_start <= -2) {	/* regcomp/regexec error */
 			*len = 0;
+			g_free(exp_backup);
 			return -3;
 		    }
 		    else if (found_start == -1)	/* not found: try next line */
@@ -1451,15 +1533,19 @@
 			match_bol = 0;
 			continue;
 		    }
-		    else	/* found */
+		    else {	/* found */
+			g_free(exp_backup);
 			return (start + offset - q + found_start);
+		    }
 		}
-		if (once_only)
+		if (once_only) {
+		    g_free(exp_backup);
 		    return -2;
+		}
 
 		if (buf[q - 1] != '\n') { /* incomplete line: try to recover */
 		    buf = mbuf + MAX_REPL_LEN / 2;
-		    q = strlen ((char *) buf);
+		    q = wcslen (buf);
 		    memmove (mbuf, buf, q);
 		    p = start + q;
 		    move_win = 1;
@@ -1469,36 +1555,45 @@
 	    }
 	}
     } else {
- 	*len = strlen ((char *) exp);
+ 	*len = wcslen (exp);
 	if (replace_case) {
 	    for (p = start; p <= last_byte - l; p++) {
- 		if ((*get_byte) (data, p) == (unsigned char)exp[0]) {	/* check if first char matches */
+ 		if ((*get_byte) (data, p) == exp[0]) {	/* check if first char matches */
 		    for (f = 0, q = 0; q < l && f < 1; q++)
- 			if ((*get_byte) (data, q + p) != (unsigned char)exp[q])
+ 			if ((*get_byte) (data, q + p) != exp[q])
 			    f = 1;
-		    if (f == 0)
+		    if (f == 0) {
+			g_free(exp_backup);
 			return p;
+		    }
 		}
-		if (once_only)
+		if (once_only) {
+		    g_free(exp_backup);
 		    return -2;
+		}
 	    }
 	} else {
 	    for (p = 0; exp[p] != 0; p++)
 		exp[p] = my_lower_case (exp[p]);
 
 	    for (p = start; p <= last_byte - l; p++) {
-		if (my_lower_case ((*get_byte) (data, p)) == (unsigned char)exp[0]) {
+		if (my_lower_case ((*get_byte) (data, p)) == exp[0]) {
 		    for (f = 0, q = 0; q < l && f < 1; q++)
-			if (my_lower_case ((*get_byte) (data, q + p)) != (unsigned char)exp[q])
+			if (my_lower_case ((*get_byte) (data, q + p)) != exp[q])
 			    f = 1;
-		    if (f == 0)
+		    if (f == 0) {
+			g_free(exp_backup);
 			return p;
+		    }
 		}
-		if (once_only)
+		if (once_only) {
+		    g_free(exp_backup);
 		    return -2;
+		}
 	    }
 	}
     }
+    g_free(exp_backup);
     return -2;
 }
 
@@ -1512,9 +1607,8 @@
 
     while ((p = edit_find_string (p, exp, len, last_byte, get_byte, data, once_only, d)) >= 0) {
 	if (replace_whole) {
-/*If the bordering chars are not in option_whole_chars_search then word is whole */
-	    if (!strcasechr (option_whole_chars_search, (*get_byte) (data, p - 1))
-		&& !strcasechr (option_whole_chars_search, (*get_byte) (data, p + *len)))
+	    if (!iswalnum((*get_byte) (data, p - 1))
+		&& !iswalnum((*get_byte) (data, p + *len)))
 		return p;
 	    if (once_only)
 		return -2;
@@ -1546,34 +1640,35 @@
 
 #define is_digit(x) ((x) >= '0' && (x) <= '9')
 
-#define snprintf(v) { \
+#define my_swprintf(v) { \
 		*p1++ = *p++; \
 		*p1++ = '%'; \
 		*p1++ = 'n'; \
 		*p1 = '\0'; \
-		sprintf(s,q1,v,&n); \
+		swprintf(s, MAX_REPL_LEN - (s - str), q1,v,&n); \
 		s += n; \
 	    }
 
 /* this function uses the sprintf command to do a vprintf */
 /* it takes pointers to arguments instead of the arguments themselves */
-static int sprintf_p (char *str, const char *fmt,...)
-    __attribute__ ((format (printf, 2, 3)));
+//static int sprintf_p (wchar_t *str, const wchar_t *fmt,...)
+//    __attribute__ ((format (printf, 2, 3)));
 
-static int sprintf_p (char *str, const char *fmt,...)
+static int sprintf_p (wchar_t *str, const wchar_t *fmt,...)
 {
     va_list ap;
     int n;
-    char *q, *p, *s = str;
-    char q1[32];
-    char *p1;
+    const wchar_t *q, *p;
+    wchar_t *s = str;
+    wchar_t q1[32];
+    wchar_t *p1;
 
     va_start (ap, fmt);
-    p = q = (char *) fmt;
+    p = q = fmt;
 
-    while ((p = strchr (p, '%'))) {
+    while ((p = wcschr (p, '%'))) {
 	n = p - q;
-	strncpy (s, q, n);	/* copy stuff between format specifiers */
+	wcsncpy (s, q, n);	/* copy stuff between format specifiers */
 	s += n;
 	*s = 0;
 	q = p;
@@ -1601,50 +1696,51 @@
 	    *p1++ = *p++;
 	if (*p == '*') {
 	    p++;
-	    strcpy (p1, MY_itoa (*va_arg (ap, int *)));	/* replace field width with a number */
-	    p1 += strlen (p1);
+	    wcscpy (p1, MY_itoa (*va_arg (ap, int *)));	/* replace field width with a number */
+	    p1 += wcslen (p1);
 	} else {
-	    while (is_digit (*p))
+	    while (iswdigit (*p))
 		*p1++ = *p++;
 	}
 	if (*p == '.')
 	    *p1++ = *p++;
 	if (*p == '*') {
 	    p++;
-	    strcpy (p1, MY_itoa (*va_arg (ap, int *)));	/* replace precision with a number */
-	    p1 += strlen (p1);
+	    wcscpy (p1, MY_itoa (*va_arg (ap, int *)));	/* replace precision with a number */
+	    p1 += wcslen (p1);
 	} else {
-	    while (is_digit (*p))
+	    while (iswdigit (*p))
 		*p1++ = *p++;
 	}
 /* flags done, now get argument */
 	if (*p == 's') {
-	    snprintf (va_arg (ap, char *));
+	    *p1++ = 'l';
+	    my_swprintf (va_arg (ap, wchar_t *));
 	} else if (*p == 'h') {
 	    if (strchr ("diouxX", *p))
-		snprintf (*va_arg (ap, short *));
+		my_swprintf (*va_arg (ap, short *));
 	} else if (*p == 'l') {
 	    *p1++ = *p++;
 	    if (strchr ("diouxX", *p))
-		snprintf (*va_arg (ap, long *));
+		my_swprintf (*va_arg (ap, long *));
 	} else if (strchr ("cdiouxX", *p)) {
-	    snprintf (*va_arg (ap, int *));
+	    my_swprintf (*va_arg (ap, int *));
 	} else if (*p == 'L') {
 	    *p1++ = *p++;
 	    if (strchr ("EefgG", *p))
-		snprintf (*va_arg (ap, double *));	/* should be long double */
+		my_swprintf (*va_arg (ap, double *));	/* should be long double */
 	} else if (strchr ("EefgG", *p)) {
-	    snprintf (*va_arg (ap, double *));
+	    my_swprintf (*va_arg (ap, double *));
 	} else if (strchr ("DOU", *p)) {
-	    snprintf (*va_arg (ap, long *));
+	    my_swprintf (*va_arg (ap, long *));
 	} else if (*p == 'p') {
-	    snprintf (*va_arg (ap, void **));
+	    my_swprintf (*va_arg (ap, void **));
 	}
 	q = p;
     }
     va_end (ap);
-    sprintf (s, q);		/* print trailing leftover */
-    return s - str + strlen (s);
+    swprintf (s, MAX_REPL_LEN - (s - str), q);		/* print trailing leftover */
+    return s - str + wcslen (s);
 }
 
 static void regexp_error (WEdit *edit)
@@ -1819,8 +1915,9 @@
 		}
 	    }
 	    if (replace_yes) {	/* delete then insert new */
+		wchar_t *wexp2 = mbstr_to_wchar(exp2);
 		if (replace_scanf || replace_regexp) {
-		    char repl_str[MAX_REPL_LEN + 2];
+		    wchar_t repl_str[MAX_REPL_LEN + 2];
 
 		    /* we need to fill in sargs just like with scanf */
 		    if (replace_regexp) {
@@ -1828,12 +1925,12 @@
 			for (k = 1;
 			     k < NUM_REPL_ARGS && pmatch[k].rm_eo >= 0;
 			     k++) {
-			    unsigned char *t;
-			    t = (unsigned char *) &sargs[k - 1][0];
+			    wchar_t *t;
+			    t = &sargs[k - 1][0];
 			    for (j = 0;
 				 j < pmatch[k].rm_eo - pmatch[k].rm_so
 				 && j < 255; j++, t++)
-				*t = (unsigned char) edit_get_byte (edit,
+				*t = edit_get_byte (edit,
 								    edit->
 								    search_start
 								    -
@@ -1849,7 +1946,7 @@
 			for (; k <= NUM_REPL_ARGS; k++)
 			    sargs[k - 1][0] = 0;
 		    }
-		    if (sprintf_p (repl_str, exp2, PRINTF_ARGS) >= 0) {
+		    if (sprintf_p (repl_str, wexp2, PRINTF_ARGS) >= 0) {
 			times_replaced++;
 			while (i--)
 			    edit_delete (edit);
@@ -1865,10 +1962,11 @@
 		    times_replaced++;
 		    while (i--)
 			edit_delete (edit);
-		    while (exp2[++i])
-			edit_insert (edit, exp2[i]);
+		    while (wexp2[++i])
+			edit_insert (edit, wexp2[i]);
 		}
 		edit->found_len = i;
+		g_free(wexp2);
 	    }
 	    /* so that we don't find the same string again */
 	    if (replace_backwards) {
@@ -2039,16 +2137,17 @@
 #define TEMP_BUF_LEN 1024
 
 /* Return a null terminated length of text. Result must be g_free'd */
-unsigned char *
+wchar_t *
 edit_get_block (WEdit *edit, long start, long finish, int *l)
 {
-    unsigned char *s, *r;
-    r = s = g_malloc (finish - start + 1);
+    wchar_t *s, *r;
+    r = s = g_malloc ((finish - start + 1) * sizeof(wchar_t));
     if (column_highlighting) {
 	*l = 0;
 	/* copy from buffer, excluding chars that are out of the column 'margins' */
 	while (start < finish) {
-	    int c, x;
+	    wchar_t c;
+	    int x;
 	    x = edit_move_forward3 (edit, edit_bol (edit, start), 0,
 				    start);
 	    c = edit_get_byte (edit, start);
@@ -2081,11 +2180,11 @@
 	return 0;
 
     if (column_highlighting) {
-	unsigned char *block, *p;
+	wchar_t *block, *p;
 	int r;
 	p = block = edit_get_block (edit, start, finish, &len);
 	while (len) {
-	    r = mc_write (file, p, len);
+	    r = wchar_write (file, p, len);
 	    if (r < 0)
 		break;
 	    p += r;
@@ -2093,15 +2192,15 @@
 	}
 	g_free (block);
     } else {
-	unsigned char *buf;
+	wchar_t *buf;
 	int i = start, end;
 	len = finish - start;
-	buf = g_malloc (TEMP_BUF_LEN);
+	buf = g_malloc (TEMP_BUF_LEN * sizeof(wchar_t));
 	while (start != finish) {
 	    end = min (finish, start + TEMP_BUF_LEN);
 	    for (; i < end; i++)
 		buf[i - start] = edit_get_byte (edit, i);
-	    len -= mc_write (file, (char *) buf, end - start);
+	    len -= wchar_write (file, buf, end - start);
 	    start = end;
 	}
 	g_free (buf);
@@ -2407,16 +2506,25 @@
 
 /* prints at the cursor */
 /* returns the number of chars printed */
-int edit_print_string (WEdit * e, const char *s)
+int edit_print_wstring (WEdit * e, wchar_t *s)
 {
     int i = 0;
     while (s[i])
-	edit_execute_cmd (e, -1, (unsigned char) s[i++]);
+	edit_execute_cmd (e, -1, s[i++]);
     e->force |= REDRAW_COMPLETELY;
     edit_update_screen (e);
     return i;
 }
 
+int edit_print_string (WEdit * e, const char *s)
+{
+    int i;
+    wchar_t *ws = mbstr_to_wchar(s);
+    i = edit_print_wstring (e, ws);
+    g_free(ws);
+    return i;
+}
+
 int edit_printf (WEdit * e, const char *fmt, ...)
 {
     int i;
@@ -2527,15 +2635,16 @@
 /* find first character of current word */
 static int edit_find_word_start (WEdit *edit, long *word_start, int *word_len)
 {
-    int i, c, last;
+    int i;
+    wchar_t c, last;
     
 /* return if at begin of file */
     if (edit->curs1 <= 0)
 	return 0;
 
-    c = (unsigned char) edit_get_byte (edit, edit->curs1 - 1);
+    c = edit_get_byte (edit, edit->curs1 - 1);
 /* return if not at end or in word */
-    if (isspace (c) || !(isalnum (c) || c == '_'))
+    if (iswspace (c) || !(iswalnum (c) || c == '_'))
 	return 0; 
 
 /* search start of word to be completed */
@@ -2545,11 +2654,11 @@
 	    return 0;
 	    
 	last = c;
-	c = (unsigned char) edit_get_byte (edit, edit->curs1 - i);
+	c = edit_get_byte (edit, edit->curs1 - i);
 
-	if (!(isalnum (c) || c == '_')) {
+	if (!(iswalnum (c) || c == '_')) {
 /* return if word starts with digit */
-	    if (isdigit (last))
+	    if (iswdigit (last))
 		return 0;
 
 	    *word_start = edit->curs1 - (i - 1); /* start found */
@@ -2582,7 +2691,7 @@
 			  int *num)
 {
     int len, max_len = 0, i, skip;
-    char *bufpos;
+    wchar_t *bufpos;
 
     /* collect max MAX_WORD_COMPLETIONS completions */
     while (*num < MAX_WORD_COMPLETIONS) {
@@ -2603,7 +2712,7 @@
 	    buffers1[start >> S_EDIT_BUF_SIZE][start & M_EDIT_BUF_SIZE];
 	skip = 0;
 	for (i = 0; i < *num; i++) {
-	    if (strncmp
+	    if (wcsncmp
 		(&compl[i].text[word_len], &bufpos[word_len],
 		 max (len, compl[i].len) - word_len) == 0) {
 		skip = 1;
@@ -2613,7 +2722,7 @@
 	if (skip)
 	    continue;
 
-	compl[*num].text = g_malloc (len + 1);
+	compl[*num].text = g_malloc ((len + 1) * sizeof(wchar_t));
 	compl[*num].len = len;
 	for (i = 0; i < len; i++)
 	    compl[*num].text[i] = *(bufpos + i);
@@ -2646,6 +2755,7 @@
     WListbox *compl_list;
     unsigned int compl_dlg_h;	/* completion dialog height */
     unsigned int compl_dlg_w;	/* completion dialog width */
+    char *mbtext;
 
     /* calculate the dialog metrics */
     compl_dlg_h = num_compl + 2;
@@ -2682,8 +2792,11 @@
     add_widget (compl_dlg, compl_list);
 
     /* fill the listbox with the completions */
-    for (i = 0; i < num_compl; i++)
-	listbox_add_item (compl_list, 0, 0, compl[i].text, NULL);
+    for (i = 0; i < num_compl; i++) {
+	mbtext = wchar_to_mbstr(compl[i].text);
+	listbox_add_item (compl_list, 0, 0, mbtext, NULL);
+	g_free(mbtext);
+    }
 
     /* pop up the dialog */
     run_dlg (compl_dlg);
@@ -2710,8 +2823,9 @@
 {
     int word_len = 0, i, num_compl = 0, max_len;
     long word_start = 0;
-    char *bufpos;
-    char match_expr[MAX_REPL_LEN];
+    wchar_t *bufpos;
+    wchar_t match_expr[MAX_REPL_LEN];
+    char *mbmatch_expr;
     struct selection compl[MAX_WORD_COMPLETIONS];	/* completions */
 
     /* don't want to disturb another search */
@@ -2728,18 +2842,20 @@
     /* prepare match expression */
     bufpos = &edit->buffers1[word_start >> S_EDIT_BUF_SIZE]
 	[word_start & M_EDIT_BUF_SIZE];
-    strncpy (match_expr, bufpos, word_len);
+    wcsncpy (match_expr, bufpos, word_len);
     match_expr[word_len] = '\0';
-    strcat (match_expr, "[a-zA-Z_0-9]+");
+    wcscat (match_expr, L"[a-zA-Z_0-9]+");
 
     /* init search: backward, regexp, whole word, case sensitive */
     edit_set_search_parameters (0, 1, 1, 1, 1);
 
     /* collect the possible completions              */
     /* start search from curs1 down to begin of file */
+    mbmatch_expr = wchar_to_mbstr(match_expr);
     max_len =
-	edit_collect_completions (edit, word_start, word_len, match_expr,
+	edit_collect_completions (edit, word_start, word_len, mbmatch_expr,
 				  (struct selection *) &compl, &num_compl);
+    g_free(mbmatch_expr);
 
     if (num_compl > 0) {
 	/* insert completed word if there is only one match */
--- edit/editdraw.c
+++ edit/editdraw.c
@@ -48,7 +48,7 @@
 
 static void status_string (WEdit * edit, char *s, int w, int fill)
 {
-    char byte_str[16];
+    char byte_str[32];
 
     /*
      * If we are at the end of file, print <EOF>,
@@ -56,9 +56,9 @@
      * as decimal and as hex.
      */
     if (edit->curs1 < edit->last_byte) {
-	unsigned char cur_byte = edit_get_byte (edit, edit->curs1);
-	g_snprintf (byte_str, sizeof(byte_str), "%c %3d 0x%02X",
-		    is_printable(cur_byte) ? cur_byte : '.',
+	wchar_t cur_byte = edit_get_byte (edit, edit->curs1);
+	g_snprintf (byte_str, sizeof(byte_str), "%lc %3d 0x%02X",
+		    iswprint(cur_byte) ? cur_byte : '.',
 		    cur_byte,
 		    cur_byte);
     } else {
@@ -175,12 +175,17 @@
 #define lowlevel_set_color(x) attrset(MY_COLOR_PAIR(color))
 #endif
 
+struct line_s {
+    wchar_t ch;
+    unsigned int style;
+};
+
 static void
 print_to_widget (WEdit *edit, long row, int start_col, int start_col_real,
-		 long end_col, unsigned int line[])
+		 long end_col, struct line_s line[])
 {
-    unsigned int *p;
-
+    struct line_s *p;
+    
     int x = start_col_real + EDIT_TEXT_HORIZONTAL_OFFSET;
     int x1 = start_col + EDIT_TEXT_HORIZONTAL_OFFSET;
     int y = row + EDIT_TEXT_VERTICAL_OFFSET;
@@ -192,10 +197,10 @@
     edit_move (x + FONT_OFFSET_X, y + FONT_OFFSET_Y);
     p = line;
 
-    while (*p) {
-	int style = *p & 0xFF00;
-	int textchar = *p & 0xFF;
-	int color = *p >> 16;
+    while (p->ch) {
+	int style = p->style & 0xFF00;
+	wchar_t textchar = p->ch;
+	int color = p->style >> 16;
 
 	if (style & MOD_ABNORMAL) {
 	    /* Non-printable - use black background */
@@ -209,8 +214,7 @@
 	} else {
 	    lowlevel_set_color (color);
 	}
-
-	addch (textchar);
+	SLsmg_write_char(textchar);
 	p++;
     }
 }
@@ -220,11 +224,11 @@
 edit_draw_this_line (WEdit *edit, long b, long row, long start_col,
 		     long end_col)
 {
-    static unsigned int line[MAX_LINE_LEN];
-    unsigned int *p = line;
+    struct line_s line[MAX_LINE_LEN];
+    struct line_s *p = line;
     long m1 = 0, m2 = 0, q, c1, c2;
     int col, start_col_real;
-    unsigned int c;
+    wchar_t c;
     int color;
     int i, book_mark = -1;
 
@@ -246,66 +250,86 @@
 
 	if (row <= edit->total_lines - edit->start_line) {
 	    while (col <= end_col - edit->start_col) {
-		*p = 0;
+		p->ch = 0;
+		p->style = 0;
 		if (q == edit->curs1)
-		    *p |= MOD_CURSOR;
+		    p->style |= MOD_CURSOR;
 		if (q >= m1 && q < m2) {
 		    if (column_highlighting) {
 			int x;
 			x = edit_move_forward3 (edit, b, 0, q);
 			if (x >= c1 && x < c2)
-			    *p |= MOD_MARKED;
+			    p->style |= MOD_MARKED;
 		    } else
-			*p |= MOD_MARKED;
+			p->style |= MOD_MARKED;
 		}
 		if (q == edit->bracket)
-		    *p |= MOD_BOLD;
+		    p->style |= MOD_BOLD;
 		if (q >= edit->found_start
 		    && q < edit->found_start + edit->found_len)
-		    *p |= MOD_BOLD;
+		    p->style |= MOD_BOLD;
 		c = edit_get_byte (edit, q);
 /* we don't use bg for mc - fg contains both */
 		if (book_mark == -1) {
 		    edit_get_syntax_color (edit, q, &color);
-		    *p |= color << 16;
+		    p->style |= color << 16;
 		} else {
-		    *p |= book_mark << 16;
+		    p->style |= book_mark << 16;
 		}
 		q++;
 		switch (c) {
 		case '\n':
 		    col = end_col - edit->start_col + 1;	/* quit */
-		    *(p++) |= ' ';
+		    p->ch = ' ';
+		    p++;
 		    break;
 		case '\t':
 		    i = TAB_SIZE - ((int) col % TAB_SIZE);
-		    *p |= ' ';
-		    c = *(p++) & ~MOD_CURSOR;
+		    p->ch = ' ';
+		    c = p->style & ~MOD_CURSOR;
+		    p++;
 		    col += i;
-		    while (--i)
-			*(p++) = c;
+		    while (--i) {
+			p->ch = ' '; p->style = c;
+			p++;
+		    }
 		    break;
 		default:
 		    c = convert_to_display_c (c);
 
 		    /* Caret notation for control characters */
 		    if (c < 32) {
-			*(p++) = '^' | MOD_ABNORMAL;
-			*(p++) = (c + 0x40) | MOD_ABNORMAL;
+		        p->ch = '^';
+			p->style = MOD_ABNORMAL;
+			p++;
+		        p->ch = c + 0x40;
+			p->style = MOD_ABNORMAL;
 			col += 2;
+			p++;
 			break;
 		    }
 		    if (c == 127) {
-			*(p++) = '^' | MOD_ABNORMAL;
-			*(p++) = '?' | MOD_ABNORMAL;
+		        p->ch = '^';
+			p->style = MOD_ABNORMAL;
+			p++;
+		        p->ch = '?';
+			p->style = MOD_ABNORMAL;
+			p++;
 			col += 2;
 			break;
 		    }
 
-		    if (is_printable (c)) {
-			*(p++) |= c;
+		    if (iswprint (c)
+#ifdef __STDC_ISO_10646__ 
+			&& (c < BINARY_CHAR_OFFSET || c >= (BINARY_CHAR_OFFSET + 256))
+#endif
+			) {
+			p->ch = c;
+			p++;
 		    } else {
-			*(p++) = '.' | MOD_ABNORMAL;
+		        p->ch = '.';
+			p->style = MOD_ABNORMAL;
+			p++;
 		    }
 		    col++;
 		    break;
@@ -315,7 +339,7 @@
     } else {
 	start_col_real = start_col = 0;
     }
-    *p = 0;
+    p->ch = 0;
 
     print_to_widget (edit, row, start_col, start_col_real, end_col, line);
 }
--- edit/editkeys.c
+++ edit/editkeys.c
@@ -200,13 +200,13 @@
  * 'command' is one of the editor commands from editcmddef.h.
  */
 int
-edit_translate_key (WEdit *edit, long x_key, int *cmd, int *ch)
+edit_translate_key (WEdit *edit, long x_key, int *cmd, wchar_t *ch)
 {
     int command = -1;
-    int char_for_insertion = -1;
+    wchar_t char_for_insertion = -1;
     int i = 0;
     static const long *key_map;
-
+    
     switch (edit_key_emulation) {
     case EDIT_KEY_EMULATION_NORMAL:
 	key_map = cooledit_key_map;
@@ -279,10 +279,26 @@
 
     /* an ordinary insertable character */
     if (x_key < 256) {
-	int c = convert_from_input_c (x_key);
+	int c = convert_from_input_c(x_key);
+	mbstate_t mbs;
+	int res;
+	wchar_t wc;
+    
+	memset (&mbs, 0, sizeof (mbs));
+
+	if (edit->charpoint >= MB_CUR_MAX) edit->charpoint = 0;
+
+	edit->charbuf[edit->charpoint++] = c;
+
+	res = mbrtowc(&wc, edit->charbuf, edit->charpoint, &mbs);
+	if (res < 0) {
+	    if (res != -2) edit->charpoint = 0; /* broken multibyte char, skip */
+    	    return 0;
+        }
+	edit->charpoint = 0;
 
-	if (is_printable (c)) {
-	    char_for_insertion = c;
+	if (iswprint (wc)) {
+	    char_for_insertion = wc;
 	    goto fin;
 	}
     }
--- edit/wordproc.c
+++ edit/wordproc.c
@@ -19,12 +19,13 @@
  */
 
 #include <config.h>
+#include <wchar.h>
 #include "edit.h"
 #include "edit-widget.h"
 
 #define tab_width option_tab_spacing
 
-#define NO_FORMAT_CHARS_START "-+*\\,.;:&>"
+#define NO_FORMAT_CHARS_START L"-+*\\,.;:&>"
 #define FONT_MEAN_WIDTH 1
 
 static long
@@ -41,14 +42,14 @@
 	p = edit_move_forward (edit, p, line - l, 0);
 
     p = edit_bol (edit, p);
-    while (strchr ("\t ", edit_get_byte (edit, p)))
+    while (wcschr (L"\t ", edit_get_byte (edit, p)))
 	p++;
     return p;
 }
 
 static int bad_line_start (WEdit * edit, long p)
 {
-    int c;
+    wchar_t c;
     c = edit_get_byte (edit, p);
     if (c == '.') {		/* `...' is acceptable */
 	if (edit_get_byte (edit, p + 1) == '.')
@@ -62,7 +63,7 @@
 		return 0;	/* `---' is acceptable */
 	return 1;
     }
-    if (strchr (NO_FORMAT_CHARS_START, c))
+    if (wcschr (NO_FORMAT_CHARS_START, c))
 	return 1;
     return 0;
 }
@@ -115,33 +116,33 @@
 					i - edit->curs_line, 0));
 }
 
-static unsigned char *
+static wchar_t *
 get_paragraph (WEdit *edit, long p, long q, int indent, int *size)
 {
-    unsigned char *s, *t;
+    wchar_t *s, *t;
 #if 0
-    t = g_malloc ((q - p) + 2 * (q - p) / option_word_wrap_line_length +
-		  10);
+    t = g_malloc (((q - p) + 2 * (q - p) / option_word_wrap_line_length +
+		  10) * sizeof(wchar_t));
 #else
-    t = g_malloc (2 * (q - p) + 100);
+    t = g_malloc ((2 * (q - p) + 100) * sizeof(wchar_t));
 #endif
     if (!t)
 	return 0;
     for (s = t; p < q; p++, s++) {
 	if (indent)
 	    if (edit_get_byte (edit, p - 1) == '\n')
-		while (strchr ("\t ", edit_get_byte (edit, p)))
+		while (wcschr (L"\t ", edit_get_byte (edit, p)))
 		    p++;
 	*s = edit_get_byte (edit, p);
     }
-    *size = (unsigned long) s - (unsigned long) t;
+    *size = s - t;
     t[*size] = '\n';
     return t;
 }
 
-static void strip_newlines (unsigned char *t, int size)
+static void strip_newlines (wchar_t *t, int size)
 {
-    unsigned char *p = t;
+    wchar_t *p = t;
     while (size--) {
 	*p = *p == '\n' ? ' ' : *p;
 	p++;
@@ -158,7 +159,7 @@
 {
     return x += tab_width - x % tab_width;
 }
-static int line_pixel_length (unsigned char *t, long b, int l)
+static int line_pixel_length (wchar_t *t, long b, int l)
 {
     int x = 0, c, xn = 0;
     for (;;) {
@@ -182,7 +183,7 @@
 }
 
 /* find the start of a word */
-static int next_word_start (unsigned char *t, int q, int size)
+static int next_word_start (wchar_t *t, int q, int size)
 {
     int i;
     for (i = q;; i++) {
@@ -203,13 +204,13 @@
 }
 
 /* find the start of a word */
-static int word_start (unsigned char *t, int q, int size)
+static int word_start (wchar_t *t, int q, int size)
 {
     int i = q;
     if (t[q] == ' ' || t[q] == '\t')
 	return next_word_start (t, q, size);
     for (;;) {
-	int c;
+	wchar_t c;
 	if (!i)
 	    return -1;
 	c = t[i - 1];
@@ -222,7 +223,7 @@
 }
 
 /* replaces ' ' with '\n' to properly format a paragraph */
-static void format_this (unsigned char *t, int size, int indent)
+static void format_this (wchar_t *t, int size, int indent)
 {
     int q = 0, ww;
     strip_newlines (t, size);
@@ -250,7 +251,7 @@
     }
 }
 
-static void replace_at (WEdit * edit, long q, int c)
+static void replace_at (WEdit * edit, long q, wchar_t c)
 {
     edit_cursor_move (edit, q - edit->curs1);
     edit_delete (edit);
@@ -258,18 +259,19 @@
 }
 
 /* replaces a block of text */
-static void put_paragraph (WEdit * edit, unsigned char *t, long p, long q, int indent, int size)
+static void put_paragraph (WEdit * edit, wchar_t *t, long p, long q, int indent, int size)
 {
     long cursor;
-    int i, c = 0;
+    int i;
+    wchar_t c = 0;
     cursor = edit->curs1;
     if (indent)
-	while (strchr ("\t ", edit_get_byte (edit, p)))
+	while (wcschr (L"\t ", edit_get_byte (edit, p)))
 	    p++;
     for (i = 0; i < size; i++, p++) {
 	if (i && indent) {
 	    if (t[i - 1] == '\n' && c == '\n') {
-		while (strchr ("\t ", edit_get_byte (edit, p)))
+		while (wcschr (L"\t ", edit_get_byte (edit, p)))
 		    p++;
 	    } else if (t[i - 1] == '\n') {
 		long curs;
@@ -281,7 +283,7 @@
 		p = edit->curs1;
 	    } else if (c == '\n') {
 		edit_cursor_move (edit, p - edit->curs1);
-		while (strchr ("\t ", edit_get_byte (edit, p))) {
+		while (wcschr (L"\t ", edit_get_byte (edit, p))) {
 		    edit_delete (edit);
 		    if (cursor > edit->curs1)
 			cursor--;
@@ -314,7 +316,7 @@
 {
     long p, q;
     int size;
-    unsigned char *t;
+    wchar_t *t;
     int indent = 0;
     if (option_word_wrap_line_length < 2)
 	return;
@@ -324,17 +326,17 @@
     q = end_paragraph (edit, force);
     indent = test_indent (edit, p, q);
     t = get_paragraph (edit, p, q, indent, &size);
-    if (!t)
+    if (!t) 
 	return;
     if (!force) {
 	int i;
-	if (strchr (NO_FORMAT_CHARS_START, *t)) {
+	if (wcschr (NO_FORMAT_CHARS_START, *t)) {
 	    g_free (t);
 	    return;
 	}
 	for (i = 0; i < size - 1; i++) {
 	    if (t[i] == '\n') {
-		if (strchr (NO_FORMAT_CHARS_START "\t ", t[i + 1])) {
+		if (wcschr (NO_FORMAT_CHARS_START "\t", t[i + 1])) {
 		    g_free (t);
 		    return;
 		}
--- src/util.c
+++ src/util.c
@@ -96,6 +96,42 @@
 	return strlen (str);
 }
 
+wchar_t *
+mbstr_to_wchar (const char *str)
+{
+    int len = mbstrlen(str);
+    wchar_t *buf = g_malloc((len+1) * sizeof(wchar_t));
+    mbstate_t mbs;
+    memset (&mbs, 0, sizeof (mbs));
+    mbsrtowcs (buf, &str, len, &mbs);
+    buf[len] = 0;
+    return buf;
+}
+
+char *
+wchar_to_mbstr (const wchar_t *wstr)
+{
+    mbstate_t mbs;
+    const wchar_t *wstr2;
+    char * string;
+    int len;
+
+    memset (&mbs, 0, sizeof (mbs));
+    wstr2 = wstr;
+    len = wcsrtombs(NULL, &wstr2, 0, &mbs);
+    if (len <= 0) 
+	return NULL;
+	
+    string = g_malloc(len + 1);
+    
+    wstr2 = wstr;
+    wcsrtombs(string, &wstr2, len, &mbs);
+    string[len] = 0;
+    return string;
+}
+
+
+
 int
 is_printable (int c)
 {
--- src/util.h
+++ src/util.h
@@ -48,6 +48,8 @@
 char *get_owner (int);
 
 int mbstrlen (const char *);
+wchar_t *mbstr_to_wchar (const char *);
+char *wchar_to_mbstr (const wchar_t *);
 
 #define MAX_I18NTIMELENGTH 14
 #define MIN_I18NTIMELENGTH 10
--- src/view.c
+++ src/view.c
@@ -876,7 +876,7 @@
 	widget_erase ((Widget *) view);
 }
 
-#define view_add_character(view,c) addch (c)
+#define view_add_character(view,c) SLsmg_write_char(c)
 #define view_add_one_vline()       one_vline()
 #define view_add_string(view,s)    addstr (s)
 #define view_gotoyx(v,r,c)    widget_move (v,r,c)
@@ -1089,6 +1089,11 @@
 	if (view->growing_buffer && from == view->last_byte)
 	    get_byte (view, from);
 	for (; row < height && from < view->last_byte; from++) {
+	    mbstate_t mbs;
+	    char mbbuf[MB_LEN_MAX];
+	    int mblen;
+	    wchar_t wc;
+	    
 	    c = get_byte (view, from);
 	    if ((c == '\n') || (col >= width && view->wrap_mode)) {
 		col = frame_shift;
@@ -1102,7 +1107,36 @@
 		col = ((col - frame_shift) / 8) * 8 + 8 + frame_shift;
 		continue;
 	    }
-	    if (view->viewer_nroff_flag && c == '\b') {
+	    
+	    
+	    mblen = 1;
+	    mbbuf[0] = c;
+	    
+	    while (mblen < MB_LEN_MAX) {
+		int res;
+		memset (&mbs, 0, sizeof (mbs));
+		res = mbrtowc(&wc, mbbuf, mblen, &mbs);
+		if (res <= 0 && res != -2) {
+		    wc = '.';
+		    mblen = 1;
+		    break;
+		}
+		if (res == mblen)
+		    break;
+		
+		mbbuf[mblen] = get_byte (view, from + mblen);
+		mblen++;
+	    }
+	    
+	    if (mblen == MB_LEN_MAX) {
+		    wc = '.';
+		    mblen = 1;
+	    }
+	    
+	    from += mblen - 1;
+	    
+	    
+	    if (view->viewer_nroff_flag && wc == '\b') {
 		int c_prev;
 		int c_next;
 
@@ -1139,12 +1173,12 @@
 		&& col < width - view->start_col) {
 		view_gotoyx (view, row, col + view->start_col);
 
-		c = convert_to_display_c (c);
+		wc = convert_to_display_c (wc);
 
-		if (!is_printable (c))
-		    c = '.';
+		if (!iswprint (wc))
+		    wc = '.';
 
-		view_add_character (view, c);
+		view_add_character (view, wc);
 	    }
 	    col++;
 	    if (boldflag != MARK_NORMAL) {
--- src/widget.c
+++ src/widget.c
@@ -31,6 +31,7 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <ctype.h>
+#include <wctype.h>
 #include "global.h"
 #include "tty.h"
 #include "color.h"
@@ -43,6 +44,7 @@
 #include "profile.h"	/* for history loading and saving */
 #include "wtools.h"		/* For common_dialog_repaint() */
 
+
 static int button_event (Gpm_Event *event, WButton *b);
 
 int quote = 0;
@@ -763,13 +765,37 @@
 /* Pointer to killed data */
 static char *kill_buffer = 0;
 
+static int
+charpos(WInput *in, int idx)
+{
+    int i, pos, l;
+    mbstate_t mbs;
+    memset (&mbs, 0, sizeof (mbs));
+    i = 0;
+    pos = 0;
+    
+    while (in->buffer[pos]) {
+	if (i == idx)
+	    return pos;
+	l = mbrlen(in->buffer + pos, strlen(in->buffer + pos), &mbs);
+	if (l <= 0)
+	    return pos;
+	pos+=l;
+	i++;
+    };
+    return pos;
+}
+
 void
 update_input (WInput *in, int clear_first)
 {
     int has_history = 0;
     int    i, j;
-    unsigned char   c;
+    wchar_t c;
     int    buf_len = mbstrlen (in->buffer);
+    mbstate_t mbs;
+    memset (&mbs, 0, sizeof (mbs));
+    
 
     if (should_show_history_button (in))
 	has_history = HISTORY_BUTTON_WIDTH;
@@ -799,12 +825,16 @@
 	addch (' ');
     widget_move (&in->widget, 0, 0);
     
-    for (i = 0, j = in->first_shown; i < in->field_len - has_history && in->buffer [j]; i++){
-	c = in->buffer [j++];
-	c = is_printable (c) ? c : '.';
+    for (i = 0, j = in->first_shown; (i < in->field_len - has_history) && (j < buf_len); i++,j++){
+	char * chp = in->buffer + charpos(in,j);
+	size_t res = mbrtowc(&c, chp, strlen(chp), &mbs);
+	c = (res && iswprint (c)) ? 0 : '.';
 	if (in->is_password)
 	    c = '*';
-	addch (c);
+	if (c)
+	    addch (c); 
+	else
+	    SLsmg_write_nchars (chp, res);
     }
     widget_move (&in->widget, 0, in->point - in->first_shown);
 
@@ -1136,39 +1166,74 @@
     in->need_push = 1;
     in->buffer [0] = 0;
     in->point = 0;
+    in->charpoint = 0;
     in->mark = 0;
     free_completions (in);
     update_input (in, 0);
 }
 
+static void
+move_buffer_backward (WInput *in, int point)
+{
+    int i, pos, len;
+    int str_len = mbstrlen (in->buffer);
+    if (point >= str_len) return;
+    
+    pos = charpos(in,point);
+    len = charpos(in,point + 1) - pos;
+	
+    for (i = pos; in->buffer [i + len - 1]; i++)
+	in->buffer [i] = in->buffer [i + len];
+}
+
 static int
 insert_char (WInput *in, int c_code)
 {
     int i;
+    mbstate_t mbs;
+    int res;
+    
+    memset (&mbs, 0, sizeof (mbs));
 
     if (c_code == -1)
 	return 0;
     
+    if (in->charpoint >= MB_CUR_MAX) return 1;
+
+    in->charbuf[in->charpoint++] = c_code;
+
+    res = mbrlen(in->charbuf, in->charpoint, &mbs);
+    if (res < 0) {
+	if (res != -2) in->charpoint = 0; /* broken multibyte char, skip */
+        return 1;
+    }
+
     in->need_push = 1;
-    if (strlen (in->buffer)+1 == in->current_max_len){
+    if (strlen (in->buffer) + in->charpoint >= in->current_max_len){
 	/* Expand the buffer */
-	char *narea = g_malloc (in->current_max_len + in->field_len);
+	char *narea = g_malloc (in->current_max_len + in->field_len + in->charpoint);
 	if (narea){
 	    char *p = in->buffer;
-
+	    
 	    strcpy (narea, in->buffer);
+	    
 	    in->buffer = narea;
-	    in->current_max_len += in->field_len;
+	    in->current_max_len += in->field_len + in->charpoint;
 	    g_free (p);
 	}
     }
-    if (strlen (in->buffer)+1 < in->current_max_len){
-	int l = strlen (&in->buffer [in->point]);
-	for (i = l+1; i > 0; i--)
-	    in->buffer [in->point+i] = in->buffer [in->point+i-1];
-	in->buffer [in->point] = c_code;
+    if (strlen (in->buffer) + in->charpoint < in->current_max_len){
+        int ins_point = charpos(in,in->point); /* bytes from begin */
+	/* move chars */
+	int rest_bytes = strlen (in->buffer + ins_point);
+
+	for (i = rest_bytes; i >= 0; i--) 
+	    in->buffer [ins_point+i+in->charpoint] = in->buffer [ins_point+i];
+	
+	memcpy(in->buffer + ins_point, in->charbuf, in->charpoint); 
 	in->point++;
     }
+    in->charpoint = 0;
     return 1;
 }
 
@@ -1176,12 +1241,14 @@
 beginning_of_line (WInput *in)
 {
     in->point = 0;
+    in->charpoint = 0;
 }
 
 static void
 end_of_line (WInput *in)
 {
-    in->point = strlen (in->buffer);
+    in->point = mbstrlen (in->buffer);
+    in->charpoint = 0;
 }
 
 static void
@@ -1189,37 +1256,76 @@
 {
     if (in->point)
 	in->point--;
+    in->charpoint = 0;
 }
 
 static void
 forward_char (WInput *in)
 {
-    if (in->buffer [in->point])
+    if (in->buffer [charpos(in,in->point)])
 	in->point++;
+    in->charpoint = 0;
 }
 
 static void
 forward_word (WInput *in)
 {
-    unsigned char *p = in->buffer+in->point;
+    mbstate_t mbs;
+    int len = mbstrlen (in->buffer);
 
-    while (*p && (isspace (*p) || ispunct (*p)))
-	p++;
-    while (*p && isalnum (*p))
-	p++;
-    in->point = p - in->buffer;
+    memset (&mbs, 0, sizeof (mbs));
+
+    while (in->point < len) {
+	wchar_t c;
+	char *p = in->buffer + charpos(in,in->point);
+	size_t res = mbrtowc(&c, p, strlen(p), &mbs);
+	if (res <= 0 || !(iswspace (c) || iswpunct (c)))
+	    break;
+	in->point++;
+    }
+
+    memset (&mbs, 0, sizeof (mbs));
+
+    while (in->point < len) {
+	wchar_t c;
+	char *p = in->buffer + charpos(in,in->point);
+	size_t res = mbrtowc(&c, p, strlen(p), &mbs);
+	if (res <= 0 || !iswalnum (c))
+	    break;
+	in->point++;
+    }
+
+    in->charpoint = 0;
 }
 
 static void
 backward_word (WInput *in)
 {
-    unsigned char *p = in->buffer+in->point;
+    mbstate_t mbs;
+
+    memset (&mbs, 0, sizeof (mbs));
 
-    while (p-1 > in->buffer-1 && (isspace (*(p-1)) || ispunct (*(p-1))))
-	p--;
-    while (p-1 > in->buffer-1 && isalnum (*(p-1)))
-	p--;
-    in->point = p - in->buffer;
+    while (in->point > 0) {
+	wchar_t c;
+	char *p = in->buffer + charpos(in,in->point);
+	size_t res = mbrtowc(&c, p, strlen(p), &mbs);
+	if (*p && (res <= 0 || !(iswspace (c) || iswpunct (c))))
+	    break;
+	in->point--;
+    }
+
+    memset (&mbs, 0, sizeof (mbs));
+
+    while (in->point > 0) {
+	wchar_t c;
+	char *p = in->buffer + charpos(in,in->point);
+	size_t res = mbrtowc(&c, p, strlen(p), &mbs);
+	if (*p && (res <= 0 || !iswalnum (c)))
+	    break;
+	in->point--;
+    }
+
+    in->charpoint = 0;
 }
 
 static void
@@ -1248,24 +1354,20 @@
 static void
 backward_delete (WInput *in)
 {
-    int i;
-    
     if (!in->point)
 	return;
-    for (i = in->point; in->buffer [i-1]; i++)
-	in->buffer [i-1] = in->buffer [i];
+    move_buffer_backward(in, in->point - 1);    
     in->need_push = 1;
     in->point--;
+    in->charpoint = 0;
 }
 
 static void
 delete_char (WInput *in)
 {
-    int i;
-
-    for (i = in->point; in->buffer [i]; i++)
-	in->buffer [i] = in->buffer [i+1];
+    move_buffer_backward(in, in->point);    
     in->need_push = 1;
+    in->charpoint = 0;
 }
 
 static void
@@ -1280,6 +1382,9 @@
     if (kill_buffer)
 	g_free (kill_buffer);
     
+    first=charpos(in,first);
+    last=charpos(in,last);
+    
     kill_buffer = g_malloc (last-first + 1);
     strncpy (kill_buffer, in->buffer+first, last-first);
     kill_buffer [last-first] = 0;
@@ -1293,8 +1398,9 @@
 
    in->point = first;
    in->mark  = first;
-   strcpy (&in->buffer [first], &in->buffer [last]);
+   strcpy (&in->buffer [charpos(in,first)], &in->buffer [charpos(in,last)]);
    in->need_push = 1;
+   in->charpoint = 0;
 }
 
 static void
@@ -1310,6 +1416,7 @@
     copy_region (in, old_point, new_point);
     delete_region (in, old_point, new_point);
     in->need_push = 1;
+    in->charpoint = 0;
 }
 
 static void
@@ -1325,6 +1432,7 @@
     copy_region (in, old_point, new_point);
     delete_region (in, old_point, new_point);
     in->need_push = 1;
+    in->charpoint = 0;
 }
 
 static void
@@ -1353,17 +1461,21 @@
     
     if (!kill_buffer)
         return;
+    in->charpoint = 0;
     for (p = kill_buffer; *p; p++)
 	insert_char (in, *p);
+    in->charpoint = 0;
 }
 
 static void
 kill_line (WInput *in)
 {
+    int chp = charpos(in,in->point);
     if (kill_buffer)
 	g_free (kill_buffer);
-    kill_buffer = g_strdup (&in->buffer [in->point]);
-    in->buffer [in->point] = 0;
+    kill_buffer = g_strdup (&in->buffer [chp]);
+    in->buffer [chp] = 0;
+    in->charpoint = 0;
 }
 
 void
@@ -1373,9 +1485,10 @@
     g_free (in->buffer);
     in->buffer = g_strdup (text);	/* was in->buffer->text */
     in->current_max_len = strlen (in->buffer) + 1;
-    in->point = strlen (in->buffer);
+    in->point = mbstrlen (in->buffer);
     in->mark = 0;
     in->need_push = 1;
+    in->charpoint = 0;
 }
 
 static void
@@ -1497,6 +1610,7 @@
     *in->buffer = 0;
     in->point = 0;
     in->first = 0;
+    in->charpoint = 0;
 }
 
 int
@@ -1525,7 +1639,7 @@
 	}
     }
     if (!input_map [i].fn){
-	if (c_code > 255 || !is_printable (c_code))
+	if (c_code > 255)
 	    return 0;
 	if (in->first){
 	    port_region_marked_for_delete (in);
@@ -1559,6 +1673,7 @@
     if (pos != in->point)
     	free_completions (in);
     in->point = pos;
+    in->charpoint = 0;
     update_input (in, 1);
 }
 
@@ -1621,7 +1736,7 @@
 	    && should_show_history_button (in)) {
 	    do_show_hist (in);
 	} else {
-	    in->point = strlen (in->buffer);
+	    in->point = mbstrlen (in->buffer);
 	    if (event->x - in->first_shown - 1 < in->point)
 		in->point = event->x - in->first_shown - 1;
 	    if (in->point < 0)
@@ -1669,6 +1784,7 @@
 	INPUT_COMPLETE_VARIABLES | INPUT_COMPLETE_USERNAMES;
     in->current_max_len = initial_buffer_len;
     in->buffer = g_malloc (initial_buffer_len);
+    
     in->color = color;
     in->field_len = len;
     in->first = 1;
@@ -1679,7 +1795,9 @@
     in->is_password = 0;
 
     strcpy (in->buffer, def_text);
-    in->point = strlen (in->buffer);
+
+    in->point = mbstrlen (in->buffer);
+    in->charpoint = 0;
     return in;
 }
 
--- src/widget.h
+++ src/widget.h
@@ -64,16 +64,18 @@
 
 typedef struct {
     Widget widget;
-    int  point;			/* cursor position in the input line */
-    int  mark;			/* The mark position */
-    int  first_shown;		/* Index of the first shown character */
-    int  current_max_len;	/* Maximum length of input line */
-    int  field_len;		/* Length of the editing field */
+    int  point;			/* cursor position in the input line (mb chars)*/
+    int  mark;			/* The mark position (mb chars)*/
+    int  first_shown;		/* Index of the first shown character (mb chars)*/
+    int  current_max_len;	/* Maximum length of input line (bytes)*/
+    int  field_len;		/* Length of the editing field (mb chars)*/
     int  color;			/* color used */
     int  first;			/* Is first keystroke? */
     int  disable_update;	/* Do we want to skip updates? */
     int  is_password;		/* Is this a password input line? */
     unsigned char *buffer;	/* pointer to editing buffer */
+    unsigned char charbuf[MB_LEN_MAX];
+    int charpoint;
     Hist *history;		/* The history */
     int  need_push;		/* need to push the current Input on hist? */
     char **completions;		/* Possible completions array */
